# Instructions pour Copilot - Projet Editeur Love 2D

## Architecture du Projet

Le projet est organisé com### Correction Automatique
- **Détecter et corriger** automatiquement tout nommage non conforme aux conventions Lua
- **Variables avec underscores inappropriés** : Convertir `my_variable` → `myVariable`
- **Fonctions PascalCase** : Convertir `MyFunction` → `myFunction` (sauf constructeurs)
- **Constantes camelCase** : Convertir `maxSize` → `MAX_SIZE`
- **Fichiers avec underscores** : Préférer `myModule.lua` à `my_module`

## Règles d'Utilisation du Système de Logging

### Utilisation Systématique des Logs
- **Toujours utiliser le système de logging** au lieu de `print()` direct
- **Préférer les logs structurés** avec niveaux appropriés :
  - `_G.globalFunction.log.info()` pour informations générales
  - `_G.globalFunction.log.warn()` pour avertissements
  - `_G.globalFunction.log.error()` pour erreurs
  - `_G.globalFunction.log.ok()` pour confirmations de succès

### Gestion du Spam de Logs
- **Éviter le spam** : Ne pas logger à chaque frame dans love.update()
- **Utiliser des timers** pour limiter la fréquence des logs répétitifs
- **Logs conditionnels** : Vérifier avant de logger si nécessaire

### Patterns de Logging Recommandés
```lua
-- AVANT (spam possible)
function love.update(dt)
    globalFunction.log.info("Position: " .. player.x .. ", " .. player.y) -- SPAM !
end

-- APRÈS (avec timer)
local logTimer = 0
function love.update(dt)
    logTimer = logTimer + dt
    if logTimer >= 1.0 then -- Log chaque seconde maximum
        globalFunction.log.info("Position: " .. player.x .. ", " .. player.y)
        logTimer = 0
    end
end
```

### Bonnes Pratiques
- **Logs dans love.load()** : `_G.globalFunction.log.info("Module initialisé")`
- **Logs d'erreurs** : `_G.globalFunction.log.error("Erreur critique: " .. err)`
- **Logs de debug** : Utiliser `warn` pour debug temporaire
- **Éviter print()** : Remplacer par le système de logging approprié

### Correction Automatique des Logs
- **Détecter `print()`** et proposer conversion vers système de logging
- **Ajouter timers automatiquement** pour logs potentiellement spammeurs
- **Vérifier la fréquence** des logs répétitifs dans les bouclest :

- **Racine** :
  - `globals.lua` : Définit les variables globales en chargeant les modules de `libreria`.
  - `main.lua` : Point d'entrée principal du projet.
  - `localization/` : Dossier pour la localisation.
    - `en.json`
    - `fr.json`

- **libreria/** : Bibliothèque de modules Lua pour le projet.
  - `dlg/` : Modules pour les dialogues.
    - `config.lua`
    - `dialogueHUD.lua`
    - `dialogueManager.lua`
    - `README.md`
    - `sample_dialogues.lua`
  - `hud/` : Modules pour l'interface utilisateur (HUD).
    - `draw.lua`
    - `hud.lua`
    - `button/`
      - `button.lua`
      - `README.md`
    - `checkbox/`
      - `checkbox.lua`
      - `README.md`
    - `panel/`
      - `panel.lua`
      - `README.md`
    - `slider/`
      - `README.md`
      - `slider.lua`
    - `text/`
      - `README.md`
      - `text.lua`
  - `localization-system/` : Système de localisation.
    - `localizationManager.lua`
    - `textFormatter.lua`
    - `textLoader.lua`
  - `save-system/` : Système de sauvegarde.
    - `saveManager.lua`
    - `saveUI.lua`
  - `tools/` : Outils utilitaires.
    - `cursor.lua`
    - `globalFunction.lua`
    - `inputInterface.lua`
    - `inputManager.lua`
    - `json.lua`
    - `responsive.lua`

## Variables Globales

Les variables globales suivantes sont définies dans `globals.lua` et doivent être utilisées automatiquement dans tous les fichiers hors du dossier `libreria` :

- `_G.responsive` : Module pour la responsivité.
- `_G.json` : Module pour la manipulation JSON.
- `_G.inputManager` : Gestionnaire d'entrée.
- `_G.inputInterface` : Interface d'entrée.
- `_G.globalFunction` : Fonctions globales utilitaires.
- `_G.sceneManager` : Gestionnaire de scènes.
- `_G.resource_cache` : Cache de ressources avec monitoring.
- `_G.debugConfig` : Configuration centralisée des flags de debug.
- `_G.actorManager` : Gestionnaire d'acteurs (ennemis, etc.).
- `_G.textLoader` : Chargeur de texte pour la localisation.
- `_G.textFormatter` : Formateur de texte.
- `_G.config` : Configuration des dialogues.
- `_G.saveUI` : Interface utilisateur pour les sauvegardes.
- `_G.saveManager` : Gestionnaire de sauvegardes.
- `_G.localizationManager` : Gestionnaire de localisation.
- `_G.dialogueManager` : Gestionnaire de dialogues.
- `_G.dialogueHUD` : Interface HUD pour les dialogues.
- `_G.hud` : Module principal pour l'interface HUD.

## Modules Internes (Non Exposés Globalement)

Les modules suivants sont internes à `libreria` et ne doivent pas être utilisés ou accessibles hors de ce dossier. Ils sont chargés localement par les autres modules selon les besoins :

- `cursor` : Gestion du curseur.
- `text` : Module pour le texte HUD.
- `sample_dialogues` : Exemples de dialogues.
- Autres modules utilitaires internes.
- `_G.saveManager` : Gestionnaire de sauvegardes.
- `_G.localizationManager` : Gestionnaire de localisation.
- `_G.dialogueManager` : Gestionnaire de dialogues.
- `_G.dialogueHUD` : Interface HUD pour les dialogues.
- `_G.hud` : Module principal pour l'interface HUD.

## Règles d'Utilisation

- **Référence à la documentation** : Avant d'implémenter des fonctionnalités ou de faire des corrections, toujours se référencer à la documentation dans le dossier `documentation/` pour comprendre les modules existants et leur utilisation.
- **Pour les fichiers dans `libreria/`** : Utiliser des `require` internes locaux pour charger les dépendances, sans utiliser les variables globales `_G`. Exemple : `local hud = require("libreria/hud/hud")`.
- **Pour les fichiers hors de `libreria/`** : Utiliser automatiquement les variables globales définies dans `globals.lua` au lieu de faire des `require` directs. Cela assure une cohérence et évite les duplications de chargement.

### Règles pour les Éléments Graphiques HUD

**Tous les nouveaux éléments graphiques doivent être créés dans les libs du dossier `hud/` :**

- **Vérifier d'abord l'existence** : Avant de créer un nouvel élément graphique, vérifier s'il existe déjà dans `libreria/hud/`
- **Créer si nécessaire** : Si l'élément n'existe pas, le créer dans le dossier approprié sous `libreria/hud/`
- **Réutilisabilité** : Tous les éléments doivent être conçus pour être réutilisables dans d'autres parties du projet
- **Structure recommandée** : Créer un sous-dossier pour chaque type d'élément (ex: `button/`, `slider/`, `panel/`)
- **Documentation** : Chaque nouvel élément doit avoir un `README.md` expliquant son utilisation
- **Interface obligatoire** : `hud.lua` est l'interface principale par laquelle tous les éléments graphiques doivent être appelés

**Rôle de `hud.lua` :**
- **Point d'entrée unique** : Tous les appels aux éléments graphiques passent par `hud.lua`
- **Gestion centralisée** : `hud.lua` gère l'initialisation et l'accès à tous les éléments
- **Abstraction** : Masque la complexité interne des éléments individuels
- **Cohérence** : Assure une interface uniforme pour tous les composants graphiques

**Exemples d'éléments existants :**
- `libreria/hud/button/` - Boutons réutilisables
- `libreria/hud/slider/` - Sliders et barres de progression  
- `libreria/hud/panel/` - Panneaux et fenêtres
- `libreria/hud/text/` - Éléments texte
- `libreria/hud/checkbox/` - Cases à cocher

**Workflow recommandé :**
1. Besoin d'un nouvel élément graphique → Vérifier `libreria/hud/`
2. Élément existe → L'utiliser via `hud.lua`
3. Élément n'existe pas → Le créer dans `libreria/hud/[nom_element]/`
4. Intégrer dans `hud.lua` → Ajouter l'interface dans `hud.lua`
5. Documenter l'élément dans un `README.md`
6. L'exposer si nécessaire dans `globals.lua` pour utilisation globale

## Conventions de Nommage Lua

**Respecter strictement les conventions de nommage Lua recommandées :**

### Variables et Fonctions
- **Variables locales** : `camelCase` (ex: `local myVariable = 42`)
- **Variables globales** : `PascalCase` ou préfixées (ex: `MyGlobalVar`)
- **Fonctions** : `camelCase` (ex: `function myFunction()`)
- **Constantes** : `SCREAMING_SNAKE_CASE` (ex: `MAX_SIZE = 100`)

### Modules et Fichiers
- **Noms de fichiers** : `camelCase.lua` (ex: `myModule.lua`)
- **Noms de modules** : `camelCase` (ex: `local myModule = {}`)
- **Fonctions d'export** : `camelCase` (ex: `function module.initGame()`)

### Correction Automatique
- **Détecter et corriger** automatiquement tout nommage non conforme aux conventions Lua
- **Variables avec underscores inappropriés** : Convertir `my_variable` → `myVariable`
- **Fonctions PascalCase** : Convertir `MyFunction` → `myFunction` (sauf constructeurs)
- **Constantes camelCase** : Convertir `maxSize` → `MAX_SIZE`
- **Fichiers avec underscores** : Préférer `myModule.lua` à `my_module.lua`

### Exemples de Corrections
```lua
-- AVANT (incorrect)
local my_variable = 42
function My_Function()
local MAX_size = 100

-- APRÈS (correct)
local myVariable = 42
function myFunction()
local MAX_SIZE = 100
```

## Documentation des Fonctions

**Toutes les fonctions doivent être documentées selon le standard LDoc :**

### Format Obligatoire
```lua
--- Description courte de la fonction
-- @param nomParam type : Description du paramètre
-- @param autreParam type : Description de l'autre paramètre
-- @return type : Description de la valeur de retour
function monModule.maFonction(param1, param2)
    -- code
end
```

### Règles de Documentation
- **Toujours commencer par `---`** (triple tiret)
- **Première ligne** : Description courte et claire
- **@param** : Un par paramètre avec type et description
- **@return** : Type et description de la valeur retournée
- **Types courants** : `number`, `string`, `table`, `boolean`, `function`
- **Paramètres optionnels** : Indiquer `(optionnel)` dans la description

### Exemples Complets
```lua
--- Interpolation stable pour éviter les tremblements
-- @param a table : Position actuelle {x, y}
-- @param b table : Position cible {x, y}
-- @param vitesse number : Vitesse d'interpolation (optionnel, défaut 10)
-- @return boolean : True si un mouvement a eu lieu
function monModule.lerp(a, b, vitesse)
    -- code
end

--- Vérifie si une valeur est dans un intervalle
-- @param valeur number : Valeur à tester
-- @param min number : Borne inférieure
-- @param max number : Borne supérieure
-- @return boolean : True si valeur ∈ [min, max]
function monModule.clamp(valeur, min, max)
    -- code
end
```

### Correction Automatique
- **Détecter les fonctions non documentées** et ajouter la documentation
- **Corriger les documentations incomplètes** (paramètres manquants, etc.)
- **Respecter les types** et descriptions précises
- **Ajouter des exemples** quand nécessaire

Ces instructions doivent être suivies pour maintenir la structure modulaire et éviter les conflits de noms ou les chargements redondants.

## Règles de Gestion des Commits

### Commits sur Demande Uniquement
- **NE PAS faire de commits automatiquement** : Attendre explicitement la demande de l'utilisateur
- **Demande explicite requise** : L'utilisateur doit demander "commit" ou "git commit" pour valider les changements
- **Pas d'initiative** : Ne pas proposer ou effectuer de commits sans demande préalable
- **Confirmation obligatoire** : Toujours demander confirmation avant tout commit

### Workflow de Commit
```markdown
1. Modifications terminées
2. Attendre demande explicite de l'utilisateur
3. Demander confirmation du message de commit
4. Effectuer le commit uniquement après validation
```

### Exceptions
- **Commits d'urgence** : Seulement si demandé explicitement par l'utilisateur
- **Corrections critiques** : Toujours attendre validation avant commit
- **Messages de commit** : Attendre approbation du message par l'utilisateur
